//
// DO NOT MODIFY THIS FILE DIRECTLY!
// IT IS GENERATED BY generate_policy_source.py
// FROM ../../components/policy/resources/policy_templates.json
//


#include <limits>
#include <memory>
#include <utility>
#include <string>

#include "base/callback.h"
#include "base/json/json_reader.h"
#include "base/logging.h"
#include "base/memory/ptr_util.h"
#include "base/memory/weak_ptr.h"
#include "base/values.h"
#include "components/policy/core/common/cloud/cloud_external_data_manager.h"
#include "components/policy/core/common/external_data_fetcher.h"
#include "components/policy/core/common/policy_map.h"
#include "components/policy/core/common/policy_types.h"
#include "components/policy/policy_constants.h"
#include "components/policy/proto/cloud_policy.pb.h"

using google::protobuf::RepeatedPtrField;

namespace policy {

namespace em = enterprise_management;

std::unique_ptr<base::Value> DecodeIntegerValue(
    google::protobuf::int64 value) {
  if (value < std::numeric_limits<int>::min() ||
      value > std::numeric_limits<int>::max()) {
    LOG(WARNING) << "Integer value " << value
                 << " out of numeric limits, ignoring.";
    return nullptr;
  }

  return base::WrapUnique(
      new base::Value(static_cast<int>(value)));
}

std::unique_ptr<base::ListValue> DecodeStringList(
    const em::StringList& string_list) {
  std::unique_ptr<base::ListValue> list_value(new base::ListValue);
  for (const auto& entry : string_list.entries())
    list_value->AppendString(entry);
  return list_value;
}

std::unique_ptr<base::Value> DecodeJson(const std::string& json) {
  std::unique_ptr<base::Value> root =
      base::JSONReader::Read(json, base::JSON_ALLOW_TRAILING_COMMAS);

  if (!root)
    LOG(WARNING) << "Invalid JSON string, ignoring: " << json;

  // Accept any Value type that parsed as JSON, and leave it to the handler to
  // convert and check the concrete type.
  return root;
}

void DecodePolicy(const em::CloudPolicySettings& policy,
                  base::WeakPtr<CloudExternalDataManager> external_data_manager,
                  PolicyMap* map,
                  PolicyScope scope) {
  if (policy.has_alternateerrorpagesenabled()) {
    const em::BooleanPolicyProto& policy_proto = policy.alternateerrorpagesenabled();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kAlternateErrorPagesEnabled, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_searchsuggestenabled()) {
    const em::BooleanPolicyProto& policy_proto = policy.searchsuggestenabled();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kSearchSuggestEnabled, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_networkpredictionoptions()) {
    const em::IntegerPolicyProto& policy_proto = policy.networkpredictionoptions();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(DecodeIntegerValue(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kNetworkPredictionOptions, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_javascriptenabled()) {
    const em::BooleanPolicyProto& policy_proto = policy.javascriptenabled();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kJavascriptEnabled, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_incognitoenabled()) {
    const em::BooleanPolicyProto& policy_proto = policy.incognitoenabled();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kIncognitoEnabled, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_incognitomodeavailability()) {
    const em::IntegerPolicyProto& policy_proto = policy.incognitomodeavailability();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(DecodeIntegerValue(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kIncognitoModeAvailability, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_savingbrowserhistorydisabled()) {
    const em::BooleanPolicyProto& policy_proto = policy.savingbrowserhistorydisabled();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kSavingBrowserHistoryDisabled, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_printingenabled()) {
    const em::BooleanPolicyProto& policy_proto = policy.printingenabled();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kPrintingEnabled, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_forcesafesearch()) {
    const em::BooleanPolicyProto& policy_proto = policy.forcesafesearch();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kForceSafeSearch, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_forcegooglesafesearch()) {
    const em::BooleanPolicyProto& policy_proto = policy.forcegooglesafesearch();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kForceGoogleSafeSearch, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_forceyoutubesafetymode()) {
    const em::BooleanPolicyProto& policy_proto = policy.forceyoutubesafetymode();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kForceYouTubeSafetyMode, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_forceyoutuberestrict()) {
    const em::IntegerPolicyProto& policy_proto = policy.forceyoutuberestrict();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(DecodeIntegerValue(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kForceYouTubeRestrict, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_safebrowsingenabled()) {
    const em::BooleanPolicyProto& policy_proto = policy.safebrowsingenabled();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kSafeBrowsingEnabled, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_passwordmanagerenabled()) {
    const em::BooleanPolicyProto& policy_proto = policy.passwordmanagerenabled();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kPasswordManagerEnabled, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_autofillenabled()) {
    const em::BooleanPolicyProto& policy_proto = policy.autofillenabled();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kAutoFillEnabled, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_autofillcreditcardenabled()) {
    const em::BooleanPolicyProto& policy_proto = policy.autofillcreditcardenabled();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kAutofillCreditCardEnabled, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_signinallowed()) {
    const em::BooleanPolicyProto& policy_proto = policy.signinallowed();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kSigninAllowed, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_proxymode()) {
    const em::StringPolicyProto& policy_proto = policy.proxymode();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kProxyMode, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_proxyservermode()) {
    const em::IntegerPolicyProto& policy_proto = policy.proxyservermode();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(DecodeIntegerValue(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kProxyServerMode, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_proxyserver()) {
    const em::StringPolicyProto& policy_proto = policy.proxyserver();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kProxyServer, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_proxypacurl()) {
    const em::StringPolicyProto& policy_proto = policy.proxypacurl();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kProxyPacUrl, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_proxybypasslist()) {
    const em::StringPolicyProto& policy_proto = policy.proxybypasslist();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kProxyBypassList, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_proxysettings()) {
    const em::StringPolicyProto& policy_proto = policy.proxysettings();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(DecodeJson(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kProxySettings, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_authschemes()) {
    const em::StringPolicyProto& policy_proto = policy.authschemes();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kAuthSchemes, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_disableauthnegotiatecnamelookup()) {
    const em::BooleanPolicyProto& policy_proto = policy.disableauthnegotiatecnamelookup();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kDisableAuthNegotiateCnameLookup, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_authserverwhitelist()) {
    const em::StringPolicyProto& policy_proto = policy.authserverwhitelist();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kAuthServerWhitelist, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_authnegotiatedelegatewhitelist()) {
    const em::StringPolicyProto& policy_proto = policy.authnegotiatedelegatewhitelist();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kAuthNegotiateDelegateWhitelist, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_authandroidnegotiateaccounttype()) {
    const em::StringPolicyProto& policy_proto = policy.authandroidnegotiateaccounttype();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kAuthAndroidNegotiateAccountType, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_ntlmv2enabled()) {
    const em::BooleanPolicyProto& policy_proto = policy.ntlmv2enabled();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kNtlmV2Enabled, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_extensioninstallblacklist()) {
    const em::StringListPolicyProto& policy_proto = policy.extensioninstallblacklist();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(DecodeStringList(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kExtensionInstallBlacklist, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_extensioninstallwhitelist()) {
    const em::StringListPolicyProto& policy_proto = policy.extensioninstallwhitelist();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(DecodeStringList(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kExtensionInstallWhitelist, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_extensioninstallforcelist()) {
    const em::StringListPolicyProto& policy_proto = policy.extensioninstallforcelist();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(DecodeStringList(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kExtensionInstallForcelist, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_extensioninstallsources()) {
    const em::StringListPolicyProto& policy_proto = policy.extensioninstallsources();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(DecodeStringList(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kExtensionInstallSources, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_extensionallowedtypes()) {
    const em::StringListPolicyProto& policy_proto = policy.extensionallowedtypes();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(DecodeStringList(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kExtensionAllowedTypes, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_extensionsettings()) {
    const em::StringPolicyProto& policy_proto = policy.extensionsettings();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(DecodeJson(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kExtensionSettings, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_defaultsearchproviderenabled()) {
    const em::BooleanPolicyProto& policy_proto = policy.defaultsearchproviderenabled();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kDefaultSearchProviderEnabled, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_defaultsearchprovidername()) {
    const em::StringPolicyProto& policy_proto = policy.defaultsearchprovidername();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kDefaultSearchProviderName, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_defaultsearchproviderkeyword()) {
    const em::StringPolicyProto& policy_proto = policy.defaultsearchproviderkeyword();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kDefaultSearchProviderKeyword, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_defaultsearchprovidersearchurl()) {
    const em::StringPolicyProto& policy_proto = policy.defaultsearchprovidersearchurl();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kDefaultSearchProviderSearchURL, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_defaultsearchprovidersuggesturl()) {
    const em::StringPolicyProto& policy_proto = policy.defaultsearchprovidersuggesturl();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kDefaultSearchProviderSuggestURL, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_defaultsearchprovidericonurl()) {
    const em::StringPolicyProto& policy_proto = policy.defaultsearchprovidericonurl();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kDefaultSearchProviderIconURL, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_defaultsearchproviderencodings()) {
    const em::StringListPolicyProto& policy_proto = policy.defaultsearchproviderencodings();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(DecodeStringList(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kDefaultSearchProviderEncodings, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_defaultsearchprovideralternateurls()) {
    const em::StringListPolicyProto& policy_proto = policy.defaultsearchprovideralternateurls();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(DecodeStringList(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kDefaultSearchProviderAlternateURLs, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_defaultsearchproviderimageurl()) {
    const em::StringPolicyProto& policy_proto = policy.defaultsearchproviderimageurl();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kDefaultSearchProviderImageURL, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_defaultsearchprovidernewtaburl()) {
    const em::StringPolicyProto& policy_proto = policy.defaultsearchprovidernewtaburl();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kDefaultSearchProviderNewTabURL, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_defaultsearchprovidersearchurlpostparams()) {
    const em::StringPolicyProto& policy_proto = policy.defaultsearchprovidersearchurlpostparams();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kDefaultSearchProviderSearchURLPostParams, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_defaultsearchprovidersuggesturlpostparams()) {
    const em::StringPolicyProto& policy_proto = policy.defaultsearchprovidersuggesturlpostparams();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kDefaultSearchProviderSuggestURLPostParams, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_defaultsearchproviderimageurlpostparams()) {
    const em::StringPolicyProto& policy_proto = policy.defaultsearchproviderimageurlpostparams();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kDefaultSearchProviderImageURLPostParams, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_defaultcookiessetting()) {
    const em::IntegerPolicyProto& policy_proto = policy.defaultcookiessetting();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(DecodeIntegerValue(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kDefaultCookiesSetting, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_defaultimagessetting()) {
    const em::IntegerPolicyProto& policy_proto = policy.defaultimagessetting();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(DecodeIntegerValue(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kDefaultImagesSetting, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_defaultjavascriptsetting()) {
    const em::IntegerPolicyProto& policy_proto = policy.defaultjavascriptsetting();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(DecodeIntegerValue(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kDefaultJavaScriptSetting, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_defaultpopupssetting()) {
    const em::IntegerPolicyProto& policy_proto = policy.defaultpopupssetting();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(DecodeIntegerValue(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kDefaultPopupsSetting, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_defaultgeolocationsetting()) {
    const em::IntegerPolicyProto& policy_proto = policy.defaultgeolocationsetting();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(DecodeIntegerValue(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kDefaultGeolocationSetting, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_defaultwebbluetoothguardsetting()) {
    const em::IntegerPolicyProto& policy_proto = policy.defaultwebbluetoothguardsetting();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(DecodeIntegerValue(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kDefaultWebBluetoothGuardSetting, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_defaultwebusbguardsetting()) {
    const em::IntegerPolicyProto& policy_proto = policy.defaultwebusbguardsetting();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(DecodeIntegerValue(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kDefaultWebUsbGuardSetting, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_webusbaskforurls()) {
    const em::StringListPolicyProto& policy_proto = policy.webusbaskforurls();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(DecodeStringList(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kWebUsbAskForUrls, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_webusbblockedforurls()) {
    const em::StringListPolicyProto& policy_proto = policy.webusbblockedforurls();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(DecodeStringList(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kWebUsbBlockedForUrls, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_cookiesallowedforurls()) {
    const em::StringListPolicyProto& policy_proto = policy.cookiesallowedforurls();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(DecodeStringList(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kCookiesAllowedForUrls, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_cookiesblockedforurls()) {
    const em::StringListPolicyProto& policy_proto = policy.cookiesblockedforurls();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(DecodeStringList(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kCookiesBlockedForUrls, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_cookiessessiononlyforurls()) {
    const em::StringListPolicyProto& policy_proto = policy.cookiessessiononlyforurls();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(DecodeStringList(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kCookiesSessionOnlyForUrls, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_imagesallowedforurls()) {
    const em::StringListPolicyProto& policy_proto = policy.imagesallowedforurls();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(DecodeStringList(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kImagesAllowedForUrls, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_imagesblockedforurls()) {
    const em::StringListPolicyProto& policy_proto = policy.imagesblockedforurls();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(DecodeStringList(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kImagesBlockedForUrls, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_javascriptallowedforurls()) {
    const em::StringListPolicyProto& policy_proto = policy.javascriptallowedforurls();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(DecodeStringList(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kJavaScriptAllowedForUrls, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_javascriptblockedforurls()) {
    const em::StringListPolicyProto& policy_proto = policy.javascriptblockedforurls();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(DecodeStringList(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kJavaScriptBlockedForUrls, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_popupsallowedforurls()) {
    const em::StringListPolicyProto& policy_proto = policy.popupsallowedforurls();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(DecodeStringList(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kPopupsAllowedForUrls, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_popupsblockedforurls()) {
    const em::StringListPolicyProto& policy_proto = policy.popupsblockedforurls();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(DecodeStringList(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kPopupsBlockedForUrls, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_translateenabled()) {
    const em::BooleanPolicyProto& policy_proto = policy.translateenabled();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kTranslateEnabled, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_editbookmarksenabled()) {
    const em::BooleanPolicyProto& policy_proto = policy.editbookmarksenabled();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kEditBookmarksEnabled, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_urlblacklist()) {
    const em::StringListPolicyProto& policy_proto = policy.urlblacklist();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(DecodeStringList(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kURLBlacklist, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_urlwhitelist()) {
    const em::StringListPolicyProto& policy_proto = policy.urlwhitelist();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(DecodeStringList(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kURLWhitelist, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_enablesha1forlocalanchors()) {
    const em::BooleanPolicyProto& policy_proto = policy.enablesha1forlocalanchors();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kEnableSha1ForLocalAnchors, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_enablesymanteclegacyinfrastructure()) {
    const em::BooleanPolicyProto& policy_proto = policy.enablesymanteclegacyinfrastructure();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kEnableSymantecLegacyInfrastructure, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_disablesafebrowsingproceedanyway()) {
    const em::BooleanPolicyProto& policy_proto = policy.disablesafebrowsingproceedanyway();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kDisableSafeBrowsingProceedAnyway, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_variationsrestrictparameter()) {
    const em::StringPolicyProto& policy_proto = policy.variationsrestrictparameter();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kVariationsRestrictParameter, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_supervisedusercontentproviderenabled()) {
    const em::BooleanPolicyProto& policy_proto = policy.supervisedusercontentproviderenabled();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kSupervisedUserContentProviderEnabled, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_managedbookmarks()) {
    const em::StringPolicyProto& policy_proto = policy.managedbookmarks();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(DecodeJson(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kManagedBookmarks, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_datacompressionproxyenabled()) {
    const em::BooleanPolicyProto& policy_proto = policy.datacompressionproxyenabled();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kDataCompressionProxyEnabled, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_enabledeprecatedwebplatformfeatures()) {
    const em::StringListPolicyProto& policy_proto = policy.enabledeprecatedwebplatformfeatures();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(DecodeStringList(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kEnableDeprecatedWebPlatformFeatures, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_forcebrowsersignin()) {
    const em::BooleanPolicyProto& policy_proto = policy.forcebrowsersignin();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kForceBrowserSignin, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_sslversionmin()) {
    const em::StringPolicyProto& policy_proto = policy.sslversionmin();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kSSLVersionMin, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_sslversionmax()) {
    const em::StringPolicyProto& policy_proto = policy.sslversionmax();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kSSLVersionMax, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_certificatetransparencyenforcementdisabledforurls()) {
    const em::StringListPolicyProto& policy_proto = policy.certificatetransparencyenforcementdisabledforurls();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(DecodeStringList(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kCertificateTransparencyEnforcementDisabledForUrls, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_certificatetransparencyenforcementdisabledforcas()) {
    const em::StringListPolicyProto& policy_proto = policy.certificatetransparencyenforcementdisabledforcas();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(DecodeStringList(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kCertificateTransparencyEnforcementDisabledForCas, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_certificatetransparencyenforcementdisabledforlegacycas()) {
    const em::StringListPolicyProto& policy_proto = policy.certificatetransparencyenforcementdisabledforlegacycas();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(DecodeStringList(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kCertificateTransparencyEnforcementDisabledForLegacyCas, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_contextualsearchenabled()) {
    const em::BooleanPolicyProto& policy_proto = policy.contextualsearchenabled();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kContextualSearchEnabled, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_sslerroroverrideallowed()) {
    const em::BooleanPolicyProto& policy_proto = policy.sslerroroverrideallowed();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kSSLErrorOverrideAllowed, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_alloweddomainsforapps()) {
    const em::StringPolicyProto& policy_proto = policy.alloweddomainsforapps();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kAllowedDomainsForApps, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_enablemediarouter()) {
    const em::BooleanPolicyProto& policy_proto = policy.enablemediarouter();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kEnableMediaRouter, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_ntpcontentsuggestionsenabled()) {
    const em::BooleanPolicyProto& policy_proto = policy.ntpcontentsuggestionsenabled();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kNTPContentSuggestionsEnabled, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_webrtcudpportrange()) {
    const em::StringPolicyProto& policy_proto = policy.webrtcudpportrange();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kWebRtcUdpPortRange, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_isolateoriginsandroid()) {
    const em::StringPolicyProto& policy_proto = policy.isolateoriginsandroid();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kIsolateOriginsAndroid, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_siteperprocessandroid()) {
    const em::BooleanPolicyProto& policy_proto = policy.siteperprocessandroid();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kSitePerProcessAndroid, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_restrictaccountstopatterns()) {
    const em::StringListPolicyProto& policy_proto = policy.restrictaccountstopatterns();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(DecodeStringList(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kRestrictAccountsToPatterns, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
}

}  // namespace policy
